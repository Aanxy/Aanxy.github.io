<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>js中的数据结构 | anxy</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://aanxy.github.io/favicon.ico?v=1606387333476">
<link rel="stylesheet" href="https://aanxy.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="1、数组（排序算法：冒泡排序、选择排序、快速排序。插入）
2、栈（后进先出，push，pop方法）
3、队列（先进先出）
4、链表（链表结尾插入删除元素，链表开头插入删除元素、查询）
5、树（二叉树，前序、后序、中序排列）
数组
数组是所有..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://aanxy.github.io">
        <img src="https://aanxy.github.io/images/avatar.png?v=1606387333476" class="site-logo">
        <h1 class="site-title">anxy</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://aanxy.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">js中的数据结构</h2>
            <div class="post-date">2020-11-26</div>
            
            <div class="post-content" v-pre>
              <p>1、数组（排序算法：冒泡排序、选择排序、快速排序。插入）<br>
2、栈（后进先出，push，pop方法）<br>
3、队列（先进先出）<br>
4、链表（链表结尾插入删除元素，链表开头插入删除元素、查询）<br>
5、树（二叉树，前序、后序、中序排列）</p>
<h2 id="数组">数组</h2>
<p>数组是所有数据结构中最基本的，将数据存储在内存中供以后使用。每个数组都有固定数量的单元格（取决于其创建），并且每个单元格都有用于选择其数据的相应数字索引。每当您想使用数组时，所需的就是所需的索引，并且您可以访问其中的任何数据。<br>
<img src="https://aanxy.github.io/post-images/1606378055055.png" alt="" loading="lazy"></p>
<h3 id="好处">好处</h3>
<ul>
<li>易于创建和使用</li>
</ul>
<h3 id="缺点">缺点</h3>
<ul>
<li>长度固定</li>
<li>内存中存储必须是一段连续的空间</li>
<li>排序效率低下</li>
<li>删除、插入耗时</li>
</ul>
<h3 id="应用">应用</h3>
<h4 id="1-冒泡排序">1、冒泡排序</h4>
<h5 id="a-原理">a、原理</h5>
<p>比较两个相邻的元素，将值大的元素交换放在右边，小的交换到左边</p>
<h5 id="b-思路">b、思路</h5>
<p>依次比较相邻的两个数，将比较小的数放在前面，比较大的数放在后面<br>
(1)第一次比较：首先比较第一和第二个数，将小数放在前面，将大数放在后面。<br>
(2)比较第2和第3个数，将小数 放在前面，大数放在后面。<br>
　　　　......<br>
(3)如此继续，知道比较到最后的两个数，将小数放在前面，大数放在后面，重复步骤，直至全部排序完成<br>
(4)在上面一趟比较完成后，最后一个数一定是数组中最大的一个数，所以在比较第二趟的时候，最后一个数是不参加比较的。<br>
(5)在第二趟比较完成后，倒数第二个数也一定是数组中倒数第二大数，所以在第三趟的比较中，最后两个数是不参与比较的。<br>
(6)依次类推，每一趟比较次数减少依次<br>
c、举例<br>
排序数组:[10,1,35,61,89,36,55]<br>
<img src="https://aanxy.github.io/post-images/1606378787712.png" alt="" loading="lazy"><br>
js代码实现：</p>
<pre><code>let atrr = [10,1,35,61,89,36,55]
        for(var i = 1;i&lt;atrr.length;i++){ //6次
            for(var j = 0;j&lt;atrr.length - i;j++){
                let temp = 0;
                if(atrr[j]&gt;atrr[j+1]){
                    temp = atrr[j];
                    atrr[j] = atrr[j+1]
                    atrr[j+1] = temp
                }
            }
        }
        console.log(atrr)
</code></pre>
<h2 id="栈">栈</h2>
<p>栈：是一种遵循后进先出(Last In First Out / LIFO) 原则的一种有序集合。<br>
新添加或者要删除的元素都会保存在栈的同一端，我们把它叫做栈顶，另外一端叫做栈底。<br>
在栈中所有的新元素都接近栈顶，而所有的旧元素都接近栈底。<br>
<img src="https://aanxy.github.io/post-images/1606382038485.png" alt="" loading="lazy"></p>
<h3 id="优点">优点</h3>
<ul>
<li>运行时间短</li>
<li>长度不固定</li>
<li>先进后出</li>
</ul>
<h3 id="缺点-2">缺点</h3>
<ul>
<li>只能获取栈顶的数据</li>
</ul>
<h3 id="应用-2">应用</h3>
<p>js中关于栈的应用：数据进栈与出栈<br>
<img src="https://aanxy.github.io/post-images/1606382405985.jpg" alt="" loading="lazy"><br>
js中我们通过类来进行模拟实现栈</p>
<h4 id="a-使用javascript的类来创建一个我们的栈-我们通过数组来模拟栈的存储因为数组可以在任何地方进行插入和删除">a、使用JavaScript的类来创建一个我们的栈。我们通过数组来模拟栈的存储，因为数组可以在任何地方进行插入和删除</h4>
<pre><code>class Stack{
    constructor(){
        this.items = [];
    }
}
</code></pre>
<h4 id="b-数据进栈遵循栈的先进后出只能在顶部插入因此我们在数组的尾部进行插入数据采用数组中的push方法">b、数据进栈，遵循栈的先进后出，只能在顶部插入，因此我们在数组的尾部进行插入数据，采用数组中的push方法</h4>
<pre><code>push(element) {
    this.items.push(element);
}
</code></pre>
<h3 id="c-数据出栈同样遵循先进后出因此我们在数组的尾部进行删除数据采用数组的pop方法">c、数据出栈，同样遵循先进后出，因此我们在数组的尾部进行删除数据，采用数组的pop方法</h3>
<pre><code>pop() {
    return this.items.pop();
}
</code></pre>
<p>综合上述代码</p>
<pre><code>class Stack{
        constructor(){
            this.items = [];
        }

        // 进栈
        push(element) {
            this.items.push(element);
        }
        // 出栈
        pop() {
            return this.items.pop();
        }

        // 继续为栈添加一些辅助功能
        // peek方法用于查看栈顶的元素
        peek() {
            return this.items[this.items.length - 1];
        }

        // isEmpty方法用于检查栈是否为空
        isEmpty() {
            return !this.items.length;
        }

        // clear方法用于清空栈
        clear() {
            this.items = [];
        }

        // size方法用于查看栈中元素的数量
        size() {
            return this.items.length;
        }
    }
</code></pre>
<p>使用上述栈</p>
<pre><code>// 我们先来创建一个栈验证一下是否为空
const stack = new Stack(); // 新建一个栈
console.log(stack.isEmpty()); // true

// 继续向栈中添加2个元素
stack.push('hello');
stack.push('world');

// 此时我们调用peek方法查看栈顶的元素
console.log(stack.peek()); // 'world'

// 调用size方法查看一下元素的数量
console.log(stack.size()) // 2

// 继续向栈中添加元素
stack.push('.');
stack.push('JavaScript');

// 移出一个元素
console.log(stack.pop()); // 'JavaScript'

// 清空栈
stack.clear();
console.log(stack.size()); // 0
console.log(stack.isEmpty()); // true
</code></pre>
<h2 id="队列">队列</h2>
<p>队列类似于栈。两者都是顺序结构，与栈不同的是队列遵循先进先出<br>
<img src="https://aanxy.github.io/post-images/1606386333008.png" alt="" loading="lazy"></p>
<h3 id="优点-2">优点</h3>
<ul>
<li>长度不固定</li>
<li>按照接收顺序进行处理问题</li>
<li>运行时间短</li>
</ul>
<h3 id="缺点-3">缺点</h3>
<ul>
<li>只能检索最早的数据</li>
</ul>
<h3 id="应用-3">应用</h3>
<p>js中关于队列的应用：数据进队与出队<br>
同样类似于上面的栈，我们使用类进行模拟一个队列</p>
<h4 id="a-创建队列">a、创建队列</h4>
<pre><code>class Queue{
    constructor(){
        this.items = [];
    }
}
</code></pre>
<h4 id="b-数据进队列在队列尾部添加一个数据遵循队列的先进先出我们在数组的尾部进行插入数据采用数组中的push方法">b、数据进队列，在队列尾部添加一个数据，遵循队列的先进先出，我们在数组的尾部进行插入数据，采用数组中的push方法</h4>
<pre><code>enqueue(element) {
            this.items.push(element);
}
</code></pre>
<h4 id="c-数据出队列在队列头部删除一个数据同样遵循队列的先进先出我们在数组的头部进行删除数据采用数组中的shift方法">c、数据出队列，在队列头部删除一个数据，同样遵循队列的先进先出，我们在数组的头部进行删除数据，采用数组中的shift方法</h4>
<pre><code>dequeue() {
    this.items.shift()
}
</code></pre>
<p>综合起来代码</p>
<pre><code>class Queue{
        constructor(){
            this.items = [];
        }

        // 进栈
        enqueue(element) {
            this.items.push(element);
        }
        // 出栈
        dequeue() {
            return this.items.shift();
        }

        // 继续为栈添加一些辅助功能
        //返回队首元素head
        head() {
            return this.items[0];
        }

        // 返回队尾元素
        tail() {
            return this.items[this.items.length-1];
        }

        // 返回队列是否为空
        isEmpty() {
            return !this.items.length
        }
        // clear方法用于清空栈
        clear() {
            this.items = [];
        }

        // size方法用于查看栈中元素的数量
        size() {
            return this.items.length;
        }
    }
</code></pre>
<p>具体类的使用，等同于上面栈</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://aanxy.github.io/tPVjYrx94/">
                  <h3 class="post-title">
                    原型链
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>




  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: [''],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
